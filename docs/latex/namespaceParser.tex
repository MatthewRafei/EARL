\doxysection{Parser Namespace Reference}
\hypertarget{namespaceParser}{}\label{namespaceParser}\index{Parser@{Parser}}


Provides a set of parsers as well as some helper functions to parse the grammar of EARL.  


\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structProgram}{Program}} \mbox{\hyperlink{namespaceParser_ab1d41dd88fa329f2bf7ff2dc309e0e98}{parse\+\_\+program}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em The entrypoint to parsing. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmt}{Stmt}} $>$ \mbox{\hyperlink{namespaceParser_a52269d174d13fa46ebb309581cd26354}{parse\+\_\+stmt}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtDef}{Stmt\+Def}} $>$ \mbox{\hyperlink{namespaceParser_a702b487ca07b25be721bcda9189d477c}{parse\+\_\+stmt\+\_\+def}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type statement definition. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtExpr}{Stmt\+Expr}} $>$ \mbox{\hyperlink{namespaceParser_a216c3c911ab0cdcb244f7206a24bf6ab}{parse\+\_\+stmt\+\_\+expr}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type statement expression. Examples of this are functions where there is no return value (or the value is to be ignored), or math equations for the REPL i.\+e., 1+3. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtLet}{Stmt\+Let}} $>$ \mbox{\hyperlink{namespaceParser_af3f54c424309804738d5741952b0d623}{parse\+\_\+stmt\+\_\+let}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type \textquotesingle{}let\textquotesingle{}. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtMut}{Stmt\+Mut}} $>$ \mbox{\hyperlink{namespaceParser_ae248bd26d2df118bc36e64bc874e2304}{parse\+\_\+stmt\+\_\+mut}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type mutate. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtBlock}{Stmt\+Block}} $>$ \mbox{\hyperlink{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755}{parse\+\_\+stmt\+\_\+block}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type block. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtIf}{Stmt\+If}} $>$ \mbox{\hyperlink{namespaceParser_a2861924d156eb5b94a82b56bdb526afb}{parse\+\_\+stmt\+\_\+if}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses a statement of type if. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structExpr}{Expr}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{parse\+\_\+expr}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em Parses an expression. It uses a recursive descent parser to determine precidence. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceParser_a8def027da447c4fcc9a51895ab4da066}{parse\+\_\+expect\+\_\+type}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer)
\begin{DoxyCompactList}\small\item\em A utility function for the parsers to use to expect the next token to be an EARL datatype. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}{parse\+\_\+expect\+\_\+keyword}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer, std\+::string expected)
\begin{DoxyCompactList}\small\item\em A utility function for the parsers to use to expect the next token to be an EARL keyword. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\+\_\+expect}} (\mbox{\hyperlink{structLexer}{Lexer}} \&lexer, Token\+Type expected)
\begin{DoxyCompactList}\small\item\em A utility function for the parsers to use to expect the next token to be of type {\ttfamily expected}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Provides a set of parsers as well as some helper functions to parse the grammar of EARL. 

\doxysubsection{Function Documentation}
\Hypertarget{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}\index{Parser@{Parser}!parse\_expect@{parse\_expect}}
\index{parse\_expect@{parse\_expect}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_expect()}{parse\_expect()}}
{\footnotesize\ttfamily \label{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8} 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} Parser\+::parse\+\_\+expect (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{, }\item[{Token\+Type}]{expected}{}\end{DoxyParamCaption})}



A utility function for the parsers to use to expect the next token to be of type {\ttfamily expected}. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
{\em expected} & The type to expect \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00036}{36}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00036\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00037\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok\ =\ lexer.\mbox{\hyperlink{structLexer_aa0d9bfb6911e4dcec192d61d88b577f8}{next}}();}
\DoxyCodeLine{00038\ \ \ \ \ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ !=\ expected)\ \{}
\DoxyCodeLine{00039\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{err_8hpp_a25c153b472aedde9d62e2f1ae3ce8f23}{ERR\_WARGS}}(\mbox{\hyperlink{err_8hpp_a8a44eabce4dccc3d22171ed3699b769aa92e9d6227d5534e7afc27a11179c808e}{ErrType::Syntax}},}
\DoxyCodeLine{00040\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}parse\_expect:\ expected\ \%d,\ got\ \%s\ \`{}\%s`"{}},}
\DoxyCodeLine{00041\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (\textcolor{keywordtype}{int})expected,\ tok-\/>\mbox{\hyperlink{structToken_ac4ac09b34b6599146d1005ee7d6acdec}{to\_str}}().c\_str(),\ tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}().c\_str());}
\DoxyCodeLine{00042\ \ \ \ \ \}}
\DoxyCodeLine{00043\ \ \ \ \ \textcolor{keywordflow}{return}\ tok;}
\DoxyCodeLine{00044\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}\index{Parser@{Parser}!parse\_expect\_keyword@{parse\_expect\_keyword}}
\index{parse\_expect\_keyword@{parse\_expect\_keyword}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_expect\_keyword()}{parse\_expect\_keyword()}}
{\footnotesize\ttfamily \label{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae} 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} Parser\+::parse\+\_\+expect\+\_\+keyword (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{, }\item[{std\+::string}]{expected}{}\end{DoxyParamCaption})}



A utility function for the parsers to use to expect the next token to be an EARL keyword. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
{\em expected} & The keyword to expect \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00046}{46}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00046\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00047\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok\ =\ lexer.\mbox{\hyperlink{structLexer_aa0d9bfb6911e4dcec192d61d88b577f8}{next}}();}
\DoxyCodeLine{00048\ }
\DoxyCodeLine{00049\ \ \ \ \ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ !=\ TokenType::Keyword)\ \{}
\DoxyCodeLine{00050\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{err_8hpp_a25c153b472aedde9d62e2f1ae3ce8f23}{ERR\_WARGS}}(\mbox{\hyperlink{err_8hpp_a8a44eabce4dccc3d22171ed3699b769aa92e9d6227d5534e7afc27a11179c808e}{ErrType::Syntax}},}
\DoxyCodeLine{00051\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}parse\_expect\_keyword:\ \%s\ \`{}\%s`\ is\ not\ a\ keyword"{}},}
\DoxyCodeLine{00052\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tok-\/>\mbox{\hyperlink{structToken_ac4ac09b34b6599146d1005ee7d6acdec}{to\_str}}().c\_str(),\ tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}().c\_str());}
\DoxyCodeLine{00053\ \ \ \ \ \}}
\DoxyCodeLine{00054\ \ \ \ \ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ !=\ expected)\ \{}
\DoxyCodeLine{00055\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{err_8hpp_a25c153b472aedde9d62e2f1ae3ce8f23}{ERR\_WARGS}}(\mbox{\hyperlink{err_8hpp_a8a44eabce4dccc3d22171ed3699b769aa92e9d6227d5534e7afc27a11179c808e}{ErrType::Syntax}},}
\DoxyCodeLine{00056\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}parse\_expect\_keyword:\ expected\ keyword\ \`{}\%s`,\ got\ \%s\ \`{}\%s`"{}},}
\DoxyCodeLine{00057\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ expected.c\_str(),\ tok-\/>\mbox{\hyperlink{structToken_ac4ac09b34b6599146d1005ee7d6acdec}{to\_str}}().c\_str(),\ tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}().c\_str());}
\DoxyCodeLine{00058\ \ \ \ \ \}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \ \ \textcolor{keywordflow}{return}\ tok;}
\DoxyCodeLine{00061\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a8def027da447c4fcc9a51895ab4da066}\index{Parser@{Parser}!parse\_expect\_type@{parse\_expect\_type}}
\index{parse\_expect\_type@{parse\_expect\_type}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_expect\_type()}{parse\_expect\_type()}}
{\footnotesize\ttfamily \label{namespaceParser_a8def027da447c4fcc9a51895ab4da066} 
\mbox{\hyperlink{structToken}{Token}} \texorpdfstring{$\ast$}{*} Parser\+::parse\+\_\+expect\+\_\+type (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



A utility function for the parsers to use to expect the next token to be an EARL datatype. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00063}{63}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00064\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok\ =\ lexer.\mbox{\hyperlink{structLexer_aa0d9bfb6911e4dcec192d61d88b577f8}{next}}();}
\DoxyCodeLine{00065\ \ \ \ \ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ !=\ TokenType::Type)\ \{}
\DoxyCodeLine{00066\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{err_8hpp_a25c153b472aedde9d62e2f1ae3ce8f23}{ERR\_WARGS}}(\mbox{\hyperlink{err_8hpp_a8a44eabce4dccc3d22171ed3699b769aa92e9d6227d5534e7afc27a11179c808e}{ErrType::Syntax}},}
\DoxyCodeLine{00067\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}parse\_expect\_type:\ \%s\ \`{}\%s`\ is\ not\ a\ keyword"{}},}
\DoxyCodeLine{00068\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tok-\/>\mbox{\hyperlink{structToken_ac4ac09b34b6599146d1005ee7d6acdec}{to\_str}}().c\_str(),\ tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}().c\_str());}
\DoxyCodeLine{00069\ \ \ \ \ \}}
\DoxyCodeLine{00070\ \ \ \ \ \textcolor{keywordflow}{return}\ tok;}
\DoxyCodeLine{00071\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}\index{Parser@{Parser}!parse\_expr@{parse\_expr}}
\index{parse\_expr@{parse\_expr}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_expr()}{parse\_expr()}}
{\footnotesize\ttfamily \label{namespaceParser_ada66787a9558b28ad03b52c7381d2e75} 
\mbox{\hyperlink{structExpr}{Expr}} \texorpdfstring{$\ast$}{*} Parser\+::parse\+\_\+expr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses an expression. It uses a recursive descent parser to determine precidence. 

\begin{DoxyNote}{Note}
The precidence is as follows\+: logical -\/\texorpdfstring{$>$}{>} equalitative -\/\texorpdfstring{$>$}{>} additive -\/\texorpdfstring{$>$}{>} multiplicative -\/\texorpdfstring{$>$}{>} primary. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00194}{194}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00194\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00195\ \ \ \ \ \textcolor{keywordflow}{return}\ parse\_logical\_expr(lexer);}
\DoxyCodeLine{00196\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_ab1d41dd88fa329f2bf7ff2dc309e0e98}\index{Parser@{Parser}!parse\_program@{parse\_program}}
\index{parse\_program@{parse\_program}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_program()}{parse\_program()}}
{\footnotesize\ttfamily \label{namespaceParser_ab1d41dd88fa329f2bf7ff2dc309e0e98} 
\mbox{\hyperlink{structProgram}{Program}} Parser\+::parse\+\_\+program (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



The entrypoint to parsing. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer that has the linked list of tokens to parse \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00382}{382}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00382\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00383\ \ \ \ \ std::vector<std::unique\_ptr<Stmt>>\ stmts;}
\DoxyCodeLine{00384\ }
\DoxyCodeLine{00385\ \ \ \ \ \textcolor{keywordflow}{while}\ (lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}()-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ !=\ TokenType::Eof)\ \{}
\DoxyCodeLine{00386\ \ \ \ \ \ \ \ \ stmts.push\_back(\mbox{\hyperlink{namespaceParser_a52269d174d13fa46ebb309581cd26354}{parse\_stmt}}(lexer));}
\DoxyCodeLine{00387\ \ \ \ \ \}}
\DoxyCodeLine{00388\ }
\DoxyCodeLine{00389\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{structProgram}{Program}}(std::move(stmts));}
\DoxyCodeLine{00390\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a52269d174d13fa46ebb309581cd26354}\index{Parser@{Parser}!parse\_stmt@{parse\_stmt}}
\index{parse\_stmt@{parse\_stmt}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt()}{parse\_stmt()}}
{\footnotesize\ttfamily \label{namespaceParser_a52269d174d13fa46ebb309581cd26354} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmt}{Stmt}} $>$ Parser\+::parse\+\_\+stmt (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00344}{344}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00344\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00345\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok\ =\ lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}();}
\DoxyCodeLine{00346\ }
\DoxyCodeLine{00347\ \ \ \ \ \textcolor{keywordflow}{switch}\ (tok-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}())\ \{}
\DoxyCodeLine{00348\ \ \ \ \ \textcolor{keywordflow}{case}\ TokenType::Keyword:\ \{}
\DoxyCodeLine{00349\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ \mbox{\hyperlink{common_8hpp_a24bf0e825be794bd0509448f1b5e5e09}{COMMON\_EARLKW\_LET}})\ \{}
\DoxyCodeLine{00350\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceParser_af3f54c424309804738d5741952b0d623}{parse\_stmt\_let}}(lexer);}
\DoxyCodeLine{00351\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00352\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_DEF)\ \{}
\DoxyCodeLine{00353\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ parse\_stmt\_def(lexer);}
\DoxyCodeLine{00354\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00355\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_IF)\ \{}
\DoxyCodeLine{00356\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceParser_a2861924d156eb5b94a82b56bdb526afb}{parse\_stmt\_if}}(lexer);}
\DoxyCodeLine{00357\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00358\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_RETURN)\ \{}
\DoxyCodeLine{00359\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ parse\_stmt\_return(lexer);}
\DoxyCodeLine{00360\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00361\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_WHILE)\ \{}
\DoxyCodeLine{00362\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ parse\_stmt\_while(lexer);}
\DoxyCodeLine{00363\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00364\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_FOR)\ \{}
\DoxyCodeLine{00365\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ parse\_stmt\_for(lexer);}
\DoxyCodeLine{00366\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00367\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00368\ \ \ \ \ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false}\ \&\&\ \textcolor{stringliteral}{"{}parse\_stmt:\ invalid\ keyword"{}});}
\DoxyCodeLine{00369\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00370\ \ \ \ \ \}\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00371\ \ \ \ \ \textcolor{keywordflow}{case}\ TokenType::Ident:\ \{}
\DoxyCodeLine{00372\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}(1)-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ ==\ TokenType::Lparen)\ \{}
\DoxyCodeLine{00373\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceParser_a216c3c911ab0cdcb244f7206a24bf6ab}{parse\_stmt\_expr}}(lexer);}
\DoxyCodeLine{00374\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00375\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceParser_ae248bd26d2df118bc36e64bc874e2304}{parse\_stmt\_mut}}(lexer);}
\DoxyCodeLine{00376\ \ \ \ \ \}\ \textcolor{keywordflow}{break};}
\DoxyCodeLine{00377\ \ \ \ \ \textcolor{keywordflow}{default}:}
\DoxyCodeLine{00378\ \ \ \ \ \ \ \ \ assert(\textcolor{keyword}{false}\ \&\&\ \textcolor{stringliteral}{"{}parse\_stmt:\ invalid\ statement"{}});}
\DoxyCodeLine{00379\ \ \ \ \ \}}
\DoxyCodeLine{00380\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755}\index{Parser@{Parser}!parse\_stmt\_block@{parse\_stmt\_block}}
\index{parse\_stmt\_block@{parse\_stmt\_block}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_block()}{parse\_stmt\_block()}}
{\footnotesize\ttfamily \label{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtBlock}{Stmt\+Block}} $>$ Parser\+::parse\+\_\+stmt\+\_\+block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type block. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00257}{257}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00257\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00258\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{Parser::parse\_expect}}(lexer,\ TokenType::Lbrace);}
\DoxyCodeLine{00259\ }
\DoxyCodeLine{00260\ \ \ \ \ std::vector<std::unique\_ptr<Stmt>>\ stmts;}
\DoxyCodeLine{00261\ }
\DoxyCodeLine{00262\ \ \ \ \ \textcolor{keywordflow}{while}\ (lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}()-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ !=\ TokenType::Rbrace)\ \{}
\DoxyCodeLine{00263\ \ \ \ \ \ \ \ \ std::unique\_ptr<Stmt>\ stmt\ =\ \mbox{\hyperlink{namespaceParser_a52269d174d13fa46ebb309581cd26354}{Parser::parse\_stmt}}(lexer);}
\DoxyCodeLine{00264\ \ \ \ \ \ \ \ \ stmts.push\_back(std::move(stmt));}
\DoxyCodeLine{00265\ \ \ \ \ \}}
\DoxyCodeLine{00266\ }
\DoxyCodeLine{00267\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{Parser::parse\_expect}}(lexer,\ TokenType::Rbrace);}
\DoxyCodeLine{00268\ }
\DoxyCodeLine{00269\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtBlock>(std::move(stmts));}
\DoxyCodeLine{00270\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a702b487ca07b25be721bcda9189d477c}\index{Parser@{Parser}!parse\_stmt\_def@{parse\_stmt\_def}}
\index{parse\_stmt\_def@{parse\_stmt\_def}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_def()}{parse\_stmt\_def()}}
{\footnotesize\ttfamily \label{namespaceParser_a702b487ca07b25be721bcda9189d477c} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtDef}{Stmt\+Def}} $>$ Parser\+::parse\+\_\+stmt\+\_\+def (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type statement definition. 

\begin{DoxyNote}{Note}
ex\+: def my\+\_\+func(a\+: int, b\+: int) -\/\texorpdfstring{$>$}{>} int \{ ... \} 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00292}{292}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00292\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00293\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}{parse\_expect\_keyword}}(lexer,\ COMMON\_EARLKW\_DEF);}
\DoxyCodeLine{00294\ }
\DoxyCodeLine{00295\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *\textcolor{keywordtype}{id}\ =\ \mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{Parser::parse\_expect}}(lexer,\ TokenType::Ident);}
\DoxyCodeLine{00296\ }
\DoxyCodeLine{00297\ \ \ \ \ std::vector<std::pair<std::unique\_ptr<Token>,\ std::unique\_ptr<Token>>>\ args}
\DoxyCodeLine{00298\ \ \ \ \ \ \ \ \ =\ parse\_stmt\_def\_args(lexer);}
\DoxyCodeLine{00299\ }
\DoxyCodeLine{00300\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{Parser::parse\_expect}}(lexer,\ TokenType::RightArrow);}
\DoxyCodeLine{00301\ }
\DoxyCodeLine{00302\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *rettype\ =\ \mbox{\hyperlink{namespaceParser_a8def027da447c4fcc9a51895ab4da066}{parse\_expect\_type}}(lexer);}
\DoxyCodeLine{00303\ }
\DoxyCodeLine{00304\ \ \ \ \ std::unique\_ptr<StmtBlock>\ block\ =\ \mbox{\hyperlink{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755}{Parser::parse\_stmt\_block}}(lexer);}
\DoxyCodeLine{00305\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtDef>(std::make\_unique<Token>(*\textcolor{keywordtype}{id}),}
\DoxyCodeLine{00306\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(args),}
\DoxyCodeLine{00307\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::make\_unique<Token>(*rettype),}
\DoxyCodeLine{00308\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(block));}
\DoxyCodeLine{00309\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a216c3c911ab0cdcb244f7206a24bf6ab}\index{Parser@{Parser}!parse\_stmt\_expr@{parse\_stmt\_expr}}
\index{parse\_stmt\_expr@{parse\_stmt\_expr}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_expr()}{parse\_stmt\_expr()}}
{\footnotesize\ttfamily \label{namespaceParser_a216c3c911ab0cdcb244f7206a24bf6ab} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtExpr}{Stmt\+Expr}} $>$ Parser\+::parse\+\_\+stmt\+\_\+expr (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type statement expression. Examples of this are functions where there is no return value (or the value is to be ignored), or math equations for the REPL i.\+e., 1+3. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00251}{251}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00251\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00252\ \ \ \ \ \mbox{\hyperlink{structExpr}{Expr}}\ *expr\ =\ \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{Parser::parse\_expr}}(lexer);}
\DoxyCodeLine{00253\ \ \ \ \ \mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Semicolon);}
\DoxyCodeLine{00254\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtExpr>(std::unique\_ptr<Expr>(expr));}
\DoxyCodeLine{00255\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_a2861924d156eb5b94a82b56bdb526afb}\index{Parser@{Parser}!parse\_stmt\_if@{parse\_stmt\_if}}
\index{parse\_stmt\_if@{parse\_stmt\_if}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_if()}{parse\_stmt\_if()}}
{\footnotesize\ttfamily \label{namespaceParser_a2861924d156eb5b94a82b56bdb526afb} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtIf}{Stmt\+If}} $>$ Parser\+::parse\+\_\+stmt\+\_\+if (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type if. 


\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00206}{206}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00206\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00207\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}{Parser::parse\_expect\_keyword}}(lexer,\ COMMON\_EARLKW\_IF);}
\DoxyCodeLine{00208\ }
\DoxyCodeLine{00209\ \ \ \ \ \mbox{\hyperlink{structExpr}{Expr}}\ *expr\ =\ \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{Parser::parse\_expr}}(lexer);}
\DoxyCodeLine{00210\ \ \ \ \ std::unique\_ptr<StmtBlock>\ block\ =\ \mbox{\hyperlink{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755}{Parser::parse\_stmt\_block}}(lexer);}
\DoxyCodeLine{00211\ }
\DoxyCodeLine{00212\ \ \ \ \ \textcolor{comment}{//\ Handle\ the\ \`{}else\ if`\ or\ \`{}else`\ blocks\ if\ applicable}}
\DoxyCodeLine{00213\ \ \ \ \ std::optional<std::unique\_ptr<StmtBlock>>\ else\_\ =\ \{\};}
\DoxyCodeLine{00214\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok1\ =\ lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}();}
\DoxyCodeLine{00215\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *tok2\ =\ lexer.\mbox{\hyperlink{structLexer_ae517c2c5bec6261c616e552c747b6222}{peek}}(1);}
\DoxyCodeLine{00216\ }
\DoxyCodeLine{00217\ \ \ \ \ \textcolor{keywordtype}{bool}\ tok1\_else\ =\ tok1-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ ==\ TokenType::Keyword\ \&\&\ tok1-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_ELSE;}
\DoxyCodeLine{00218\ \ \ \ \ \textcolor{keywordtype}{bool}\ tok2\_if\ =\ tok2-\/>\mbox{\hyperlink{structToken_adc598cf8fa0a7ad230bdacfd10d58d6c}{type}}()\ ==\ TokenType::Keyword\ \&\&\ tok2-\/>\mbox{\hyperlink{structToken_a5bb2331dcfe4c63adae9f2da20545c03}{lexeme}}()\ ==\ COMMON\_EARLKW\_IF;}
\DoxyCodeLine{00219\ }
\DoxyCodeLine{00220\ \ \ \ \ \textcolor{keywordflow}{if}\ (tok1\_else\ \&\&\ tok2\_if)\ \{}
\DoxyCodeLine{00221\ \ \ \ \ \ \ \ \ lexer.\mbox{\hyperlink{structLexer_a706a671d555d1cc8a6329ef83508fab8}{discard}}();}
\DoxyCodeLine{00222\ \ \ \ \ \ \ \ \ std::vector<std::unique\_ptr<Stmt>>\ tmp;}
\DoxyCodeLine{00223\ \ \ \ \ \ \ \ \ std::unique\_ptr<StmtIf>\ nested\_if\ =\ parse\_stmt\_if(lexer);}
\DoxyCodeLine{00224\ \ \ \ \ \ \ \ \ tmp.push\_back(std::move(nested\_if));}
\DoxyCodeLine{00225\ \ \ \ \ \ \ \ \ else\_\ =\ std::make\_unique<StmtBlock>(std::move(tmp));}
\DoxyCodeLine{00226\ \ \ \ \ \}}
\DoxyCodeLine{00227\ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (tok1\_else)\ \{}
\DoxyCodeLine{00228\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}{Parser::parse\_expect\_keyword}}(lexer,\ COMMON\_EARLKW\_ELSE);}
\DoxyCodeLine{00229\ \ \ \ \ \ \ \ \ else\_\ =\ \mbox{\hyperlink{namespaceParser_a6c1ef539de1de0e6b5db8444bb64f755}{parse\_stmt\_block}}(lexer);}
\DoxyCodeLine{00230\ \ \ \ \ \}}
\DoxyCodeLine{00231\ }
\DoxyCodeLine{00232\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtIf>(std::unique\_ptr<Expr>(expr),}
\DoxyCodeLine{00233\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(block),}
\DoxyCodeLine{00234\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::move(else\_));}
\DoxyCodeLine{00235\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_af3f54c424309804738d5741952b0d623}\index{Parser@{Parser}!parse\_stmt\_let@{parse\_stmt\_let}}
\index{parse\_stmt\_let@{parse\_stmt\_let}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_let()}{parse\_stmt\_let()}}
{\footnotesize\ttfamily \label{namespaceParser_af3f54c424309804738d5741952b0d623} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtLet}{Stmt\+Let}} $>$ Parser\+::parse\+\_\+stmt\+\_\+let (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type \textquotesingle{}let\textquotesingle{}. 

\begin{DoxyNote}{Note}
ex\+: let x\+: int = 3; 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00237}{237}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00237\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00238\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a7285a6be4d103b3a30771222e5ed59ae}{parse\_expect\_keyword}}(lexer,\ \mbox{\hyperlink{common_8hpp_a24bf0e825be794bd0509448f1b5e5e09}{COMMON\_EARLKW\_LET}});}
\DoxyCodeLine{00239\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *\textcolor{keywordtype}{id}\ =\ \mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Ident);}
\DoxyCodeLine{00240\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Colon);}
\DoxyCodeLine{00241\ \ \ \ \ \mbox{\hyperlink{structToken}{Token}}\ *ty\ =\ \mbox{\hyperlink{namespaceParser_a8def027da447c4fcc9a51895ab4da066}{parse\_expect\_type}}(lexer);}
\DoxyCodeLine{00242\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Equals);}
\DoxyCodeLine{00243\ \ \ \ \ \mbox{\hyperlink{structExpr}{Expr}}\ *expr\ =\ \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{Parser::parse\_expr}}(lexer);}
\DoxyCodeLine{00244\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Semicolon);}
\DoxyCodeLine{00245\ }
\DoxyCodeLine{00246\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtLet>(std::make\_unique<Token>(*\textcolor{keywordtype}{id}),}
\DoxyCodeLine{00247\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::make\_unique<Token>(*ty),}
\DoxyCodeLine{00248\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::unique\_ptr<Expr>(expr));}
\DoxyCodeLine{00249\ \}}

\end{DoxyCode}
\Hypertarget{namespaceParser_ae248bd26d2df118bc36e64bc874e2304}\index{Parser@{Parser}!parse\_stmt\_mut@{parse\_stmt\_mut}}
\index{parse\_stmt\_mut@{parse\_stmt\_mut}!Parser@{Parser}}
\doxysubsubsection{\texorpdfstring{parse\_stmt\_mut()}{parse\_stmt\_mut()}}
{\footnotesize\ttfamily \label{namespaceParser_ae248bd26d2df118bc36e64bc874e2304} 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{structStmtMut}{Stmt\+Mut}} $>$ Parser\+::parse\+\_\+stmt\+\_\+mut (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structLexer}{Lexer}} \&}]{lexer}{}\end{DoxyParamCaption})}



Parses a statement of type mutate. 

\begin{DoxyNote}{Note}
ex\+: x = 3 + a \texorpdfstring{$\ast$}{*} 4 / 2; 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em lexer} & The lexer with the linked list of tokens \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{parser_8cpp_source_l00198}{198}} of file \mbox{\hyperlink{parser_8cpp_source}{parser.\+cpp}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00198\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00199\ \ \ \ \ \mbox{\hyperlink{structExpr}{Expr}}\ *left\ =\ \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{Parser::parse\_expr}}(lexer);}
\DoxyCodeLine{00200\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Equals);}
\DoxyCodeLine{00201\ \ \ \ \ \mbox{\hyperlink{structExpr}{Expr}}\ *right\ =\ \mbox{\hyperlink{namespaceParser_ada66787a9558b28ad03b52c7381d2e75}{Parser::parse\_expr}}(lexer);}
\DoxyCodeLine{00202\ \ \ \ \ (void)\mbox{\hyperlink{namespaceParser_a4cdc5c6bdd17399df7ad11d1ef9e77a8}{parse\_expect}}(lexer,\ TokenType::Semicolon);}
\DoxyCodeLine{00203\ \ \ \ \ \textcolor{keywordflow}{return}\ std::make\_unique<StmtMut>(std::unique\_ptr<Expr>(left),\ std::unique\_ptr<Expr>(right));}
\DoxyCodeLine{00204\ \}}

\end{DoxyCode}
