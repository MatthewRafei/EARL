module BasicLexer

import "std/char.earl"

@pub enum TokenType {
    Ident=0,
    StrLit,
    IntLit,
    CharLit,
    Hash,
    LParen,
    RParen,
    LCurly,
    RCurly,
    LBracket,
    RBracket,
    Plus,
    Minus,
    Asterisk,
    ForwardSlash,
    Equals,
    Comma,
    Greaterthan,
    Lessthan,
    Colon,
    At,
    Period,
    Semicolon,
    Backtick,
    Underscore,
    Pipe,
    Ampersand,
    Hash,
    Percent,
    Caret,
    DollarSign,
    Tilde,
    Keyword,
}

class Token [lx, ty, r, c, fp] {
    @pub let lx, ty = (lx, ty);
    @pub let r, c = (r, c);
    @pub let fp = fp;
}

@pub class T [keywords] {
    @pub let tokens = [];
    let kwds = keywords;

    @pub let default_ops = {
        "+": TokenType.Plus,
        "-": TokenType.Minus,
        "*": TokenType.Asterisk,
        "/": TokenType.ForwardSlash,
        "=": TokenType.Equals,
        ",": TokenType.Comma,
        "%": TokenType.Percent,
        "$": TokenType.DollarSign,
        "^": TokenType.Caret,
        "{": TokenType.LCurly,
        "}": TokenType.RCurly,
        "(": TokenType.LParen,
        ")": TokenType.RParen,
        "[": TokenType.LBracket,
        "]": TokenType.RBracket,
        ">": TokenType.Greaterthan,
        "<": TokenType.Lessthan,
        ":": TokenType.Colon,
        "@": TokenType.At,
        ".": TokenType.Period,
        ";": TokenType.Semicolon,
        "`": TokenType.Backtick,
        "_": TokenType.Underscore,
        "|": TokenType.Pipe,
        "&": TokenType.Ampersand,
        "#": TokenType.Hash,
        "~": TokenType.Tilde
    };

    fn consume_while(s, pred) {
        let buf, i = ("", 0);
        while i < len(s) && pred(s[i]) {
            buf += str(s[i]);
            i += 1;
        }
        return (buf, i);
    }

    fn handleop(s, r, c, fp) {
        let s0 = s;
        while len(s0) > 0 {
            if this.default_ops[s0] {
                return (Token(s0, this.default_ops[s0].unwrap(), r, c, fp), len(s0));
            }
            s0.pop(len(s0)-1);
        }
        panic(f"unknown token: {s}");
    }

    @pub fn lex(src, fp) {
        let r, c = (1, 0);
        for i in 0 to len(src) {
            if src[i] == '\n' || src[i] == '\r' {
                r += 1;
                c = 0;
            }
            else if src[i] == ' ' || src[i] == '\t'{
                c += 1;
            }
            else if Char::isalpha(src[i]) || src[i] == '_' {
                let lx, dx = consume_while(src.substr(i, len(src)), |c| {
                    return Char::isalnum(c) || c == '_';
                });

                let t = none;

                foreach @ref @const kw in this.kwds {
                    if lx == kw {
                        t = some(Token(lx, TokenType.Keyword, r, c, fp));
                        break;
                    }
                }

                if !t {
                    t = some(Token(lx, TokenType.Ident, r, c, fp));
                }
                this.tokens.append(t.unwrap());
                i += dx;
                c += dx;
            }
            else if Char::isnum(src[i]) {
                let lx, dx = consume_while(src.substr(i, len(src)), |c| {
                    return Char::isnum(c);
                });
                let t = Token(lx, TokenType.IntLit, r, c, fp);
                this.tokens.append(t);
                i += dx;
                c += dx;
            }
            else if src[i] == '"' {
                let lx, dx = consume_while(src.substr(i+1, len(src)), |c| {
                    return c != '"';
                });
                let t = Token(lx, TokenType.StrLit, r, c, fp);
                this.tokens.append(t);
                i += dx+1;
                c += dx+1;
            }
            else if src[i] == '\'' {
                let lx, dx = consume_while(src.substr(i+1, len(src)), |c| {
                    return c != '\'';
                });
                let t = Token(lx, TokenType.CharLit, r, c, fp);
                this.tokens.append(t);
                i += dx+1;
                c += dx+1;
            }
            else {
                let potential_op, _ = consume_while(src.substr(i, len(src)), |c| {
                    return !Char::isalnum(c) && c != ' ' && c != '\n' && c != '\t'  && c != '\r';
                });
                let t, dx = handleop(potential_op, r, c, fp);
                this.tokens.append(t);
                i += dx-1;
                c += dx-1;
            }
        }
    }

    @pub fn next() {
        if this.sz() == 0 {
            return none;
        }
        let t = this.tokens[0];
        this.tokens.pop(0);
        return some(t);
    }

    @pub fn peek(pk) {
        if this.sz() == 0 {
            return none;
        }
        assert(pk >= 0 && pk < this.sz());
        return some(this.tokens[pk]);
    }

    @pub fn sz() {
        return len(this.tokens);
    }
}


