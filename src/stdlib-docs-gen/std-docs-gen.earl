module Main

import "std/os.earl"
import "std/io.earl"
import "std/str.earl"
import "std/utils.earl"

enum Keywords {
    DocComm = "###",
    Module = "MODULE",
    Begin = "BEGIN",
    End = "END",
    Functions = "FUNCTIONS",
    Name = "NAME",
    Parameter = "PARAMETER",
    Returns = "RETURNS",
    Description = "DESCRIPTION",
    Class = "CLASSES",
    Enums = "ENUMS",
    Variables = "VARIABLES",
}

enum State {
    None = 0,
    Variables = 1 << Utils::iota(),
    Functions = 1 << Utils::iota(),
    Classes = 1 << Utils::iota(),
    Enums = 1 << Utils::iota(),
    Module = 1 << Utils::iota(),
}

class Class [name, members, methods] {
    @pub let name = name;
    @pub let members = members;
    @pub let methods = methods;
}

class Parameter [name, ty] {
    @pub let name = name;
    @pub let ty = ty;
}

class Function [name, params, returns, desc] {
    @pub let name = name;
    @pub let params = params;
    @pub let returns = returns;
    @pub let desc = desc;
}

class Enum [name, members] {
    @pub let name = name;
    @pub let members = members;
}

class Entry [filename, module_name, funclst, classlst, enumlst, varlst] {
    @pub let header = filename.split("/")[1].split(".")[0];
    @pub let filename = filename;
    @pub let module_name = module_name;
    @pub let function_list = funclst;
    @pub let class_list = classlst;
    @pub let enum_list = enumlst;
    @pub let variable_list = varlst;
}

fn determine_state(@ref state, cmd) {
    match cmd[0] {
        Keywords.Module -> {
            state = State.Module;
        }
        Keywords.Begin when cmd[1] == Keywords.Functions -> {
            state `|= State.Functions;
        }
        Keywords.Begin when cmd[1] == Keywords.Classes -> {
            state `|= State.Classes;
        }
        Keywords.Begin when cmd[1] == Keywords.Variables -> {
            state `|= State.Variables;
        }
        Keywords.Begin when cmd[1] == Keywords.Enums -> {
            state `|= State.Enums;
        }
        Keywords.End when cmd[1] == Keywords.Functions -> {
            state `&= `~State.Functions;
        }
        Keywords.End when cmd[1] == Keywords.Classes -> {
            state `&= `~State.Classes;
        }
        Keywords.End when cmd[1] == Keywords.Enums -> {
            state `&= `~State.Enums;
        }
        Keywords.End when cmd[1] == Keywords.Variables -> {
            state `&= `~State.Variables;
        }
        _ -> { return false; }
    }
    return true;
}

fn gen_from_file(content) {
    let state = State.None;

    let lines = content
        .split("\n")
        .filter(|line| { return len(line) > 0; });

    let module_name = "";
    let function_list, class_list, enum_list, variable_list = ([], [], [], []);

    let cur_function = Function("", [], "", "");

    for i in 0 to len(lines) {
        let line = lines[i];
        if len(line) > 3 && line.substr(0, 3) == Keywords.DocComm {
            let cmd = line
                .substr(3, len(line))                # Move past `###`
                .split(" ")                          # Get the keywords
                .filter(|k| { return len(k) > 0; }); # Remove empty lines
            if (determine_state(state, cmd)) {
                continue;
            }
        }
    }

    return (module_name, function_list, class_list, enum_list, variable_list);
}

fn main() {
    let entries = [];
    let stdlib = OS::ls("../src/std/");
    foreach file in stdlib {
        if file == "../src/std/os.earl" {
            let module_name, function_list, class_list, enum_list, variable_list
                = gen_from_file(IO::file_to_str(file));
            entries.append(Entry(file, module_name, function_list, class_list, enum_list, variable_list));
        }
    }
}

main();
