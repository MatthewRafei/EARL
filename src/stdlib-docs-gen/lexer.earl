module Lexer

import "std/char.earl"

@pub enum TokenType {
    Ident=0,
    StrLit,
    IntLit,
    Hash,
    LParen,
    RParen,
    LCurly,
    RCurly,
    LBracket,
    RBracket,
    Plus,
    Minus,
    Asterisk,
    ForwardSlash,
}

@pub class Token [lx, ty, r, c, fp] {
    @pub let lx = lx;
    @pub let ty = ty;
    @pub let r = r;
    @pub let c = c;
    @pub let fp = fp;
}

@pub class T [keywords, comm, mtlcomm_start, mtlcomm_end, ops] {
    @pub let tokens = [];
    let kwds, comm, ops = (keywords, comm, ops);
    let mtlcomm_start, mtlcomm_end = (mtlcomm_start, mtlcomm_end);

    let default_ops = {
        "+": TokenType.Plus,
        "-": TokenType.Minus,
        "*": TokenType.Asterisk,
        "/": TokenType.ForwardSlash
    };

    fn consume_while(s, pred) {
        let buf, i = ("", 0);
        while i < len(s) && pred(s[i]) {
            buf += str(s[i]);
            i += 1;
        }
        return (buf, i);
    }

    @pub fn lex(src, fp) {
        let r, c = (1, 0);
        for i in 0 to len(src) {
            if src[i] == '\n' {
                r += 1;
                c = 0;
            }
            else if Char::isalpha(src[i]) {
                let lx, dx = consume_while(src.substr(i, len(src)), |c| {
                    return Char::isalpha(c) || c == '_';
                });
                let t = some(Token(lx, TokenType.Ident, r, c, fp));
                this.tokens.append(t);
                i += dx;
                c += dx;
            }
            else if Char::isnum(src[i]) {
                let lx, dx = consume_while(src.substr(i, len(src)), |c| {
                    return Char::isnum(c);
                });
                let t = some(Token(lx, TokenType.IntLit, r, c, fp));
                this.tokens.append(t);
                i += dx;
                c += dx;
            }
            else if src[i] == '"' {
                let lx, dx = consume_while(src.substr(i+1, len(src)), |c| {
                    return c != '"';
                });
                let t = some(Token(lx, TokenType.StrLit, r, c, fp));
                this.tokens.append(t);
                i += dx+1;
                c += dx+1;
            }
        }
    }

    @pub fn next() {
        if this.sz() == 0 {
            return none;
        }
        let t = this.tokens[0];
        this.tokens.pop(0);
        return some(t);
    }

    @pub fn peek(pk) {
        if this.sz() == 0 {
            return none;
        }
        assert(pk >= 0 && pk < this.sz());
        return some(this.tokens[pk]);
    }

    @pub fn sz() {
        return len(this.tokens);
    }
}


