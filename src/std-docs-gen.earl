# MIT License

# Copyright (c) 2023 malloc-nbytes

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

module Main

import "std/os.earl"
import "std/io.earl"
import "std/str.earl"

enum Keywords {
    DocComm = "###",
    Module = "MODULE",
    Begin = "BEGIN",
    End = "END",
    Functions = "FUNCTIONS",
    Name = "NAME",
    Parameter = "PARAMETER",
    Returns = "RETURNS",
    Description = "DESCRIPTION",
    Class = "CLASS",
    Enum = "ENUM",
    Variable = "VARIABLE",
}

enum State {
    Functions = 0,
    Class,
    Enum,
    None,
    Module,
}

class Class [name, members, methods] {
    @pub let name = name;
    @pub let members = members;
    @pub let methods = methods;
}

class Function [name, params, returns, desc] {
    @pub let name = name;
    @pub let params = params;
    @pub let returns = returns;
    @pub let desc = desc;
}

class Enum [name, members] {
    @pub let name = name;
    @pub let members = members;
}

class Entry [filename, module_name, funclst, classlst, enumlst, varlst] {
    @pub let header = filename.split("/")[1].split(".")[0];
    @pub let filename = filename;
    @pub let module_name = module_name;
    @pub let function_list = funclst;
    @pub let class_list = classlst;
    @pub let enum_list = enumlst;
    @pub let variable_list = varlst;
}

# fn gen_from_file(content) {
#     let state = State.None;

#     let lines = content
#         .split("\n")
#         .filter(|line| { return len(line) > 0; });

#     let module_name = "";
#     let function_list, class_list, enum_list, variable_list = ([], [], [], []);

#     foreach line in lines {
#         if len(line) > 3 && line.substr(0, 3) == Keywords.DocComm {
#             let cmd = line
#                 .substr(3, len(line))                # Move past `###`
#                 .split(" ")                          # Get the keywords
#                 .filter(|k| { return len(k) > 0; }); # Remove empty lines

#             match cmd[0] {
#                 Keywords.Module -> {
#                     state = State.Module;
#                 }
#                 Keywords.Begin when cmd[1] == Keywords.Functions -> {
#                     state = State.Functions;
#                 }
#                 Keywords.End when cmd[1] == Keywords.Functions -> {
#                     state = State.None;
#                 }
#             }
#         }
#         else {
#             match state {
#                 State.Module -> {
#                 }
#             }
#         }
#     }

#     return (module_name, function_list, class_list, enum_list, variable_list);
# }

let entries = [];
let stdlib = OS::ls("../src/std/");
foreach file in stdlib {
    if file == "../src/std/os.earl" {
        # let module_name, function_list, class_list, enum_list, variable_list
        #     = gen_from_file(IO::file_to_str(file));

        # entries.append(Entry(file, module_name, function_list, class_list, enum_list, variable_list));
    }
}

