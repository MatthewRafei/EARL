#+TITLE: EARL Lanugage Reference
#+DESCRIPTION: The "ins" and "outs" of EARL
#+AUTHOR: Zachary Haskins (malloc-nbytes)
#+EMAIL: zdhdev@yahoo.com
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: num:nil

_*NOTE for Grammar sections of this document*:_

#+begin_quote
- =This text format represents keywords=
- /This text format represents a type of grammar/
- <text> represents an identifier
- | represents OR
- [text] means list
- *(text) either 0 or more _of_
- ?(text) means 0 or 1 _of_
- "text" represents a string
#+end_quote

* Your First Program

To jump right into testing out EARL, do the following to implement a /Hello World!/ program.

Create a new file called =hello.earl=

#+begin_example
module Main

print("Hello World!");
#+end_example

Then run

#+begin_src bash
  earl ./hello.earl
#+end_src

Output:

#+begin_example
Hello World!
#+end_example

* REPL

** REPL Commands

#+begin_quote
If you were to just start =earl= without any files, it will
launch the built-in REPL. Here you can evaluate and run
code that is provided.

When in the REPL, typing =:= <cmd> will run a REPL command.
It will not evaluate any code, but you can use it to show the current session,
edit lines that have already been typed, remove lines, and more. Typing =$= <cmd> will issue
a shell command. To view more information, launch the REPL and type =:help=.
#+end_quote

** REPL Programming

#+begin_quote
If a line that is typed does not start with =:= or =$=, it will be
interpreted as code. Upon hitting =<enter>=, it will not immediately
evaluate the code. It only does code evaluation when an empty line is processed.
Because of this, you can code in _sessions_. Starting a new session does not mean
that the current environment is lost, but it essentially focuses on a new code block.
As long as =<enter>= has not been hit on an empty line, you can continue to write code
and have it wait to be evaluated. One benefit to this is that if a mistake has been made,
you can edit it or remove that line entirely by using the REPL command =:e= or =:rm=.
Keep in mind that as soon as =<enter>= is performed on an empty line, you will _not_ be
able to go back and change it as it starts a new session.

You will know when a new session starts because the line numbers on the left will reset to 0
and the last evaluated expression will have its result printed to stdout.

Using the REPL allows for one major benefit, which is immediate evaluation of _any_ expression.
This means that if =1 + 2;= is typed into the REPL followed by =<enter><enter>=, it will print
=3 -> int= (the value and the type). Here are some examples.

*Note*: The line numbers are provided from the REPL and you do not type these in.

#+begin_example
0: let x = 1;
1: x;
2:
<unit> -> unit
1 -> int
0:
#+end_example

The first result =<unit> -> unit= is the result type of the =let= statement and can be ignored
as it's not important. The second output =1 -> int= is the result of =x;=.

Starting a new session does not remove variables that were created. That means that this is also valid:

#+begin_example
0: let x = 1;
1:
<unit> -> unit
0: x;
1:
1 -> int
0:
#+end_example

If you just want to do some quick math and use EARL as a calculator, here is another example:

#+begin_example
0: -(3 * (0.5 / float(2)) - 1);
1:
0.25 -> float
0:
#+end_example

It is important to note that if inside ={ }=, =[ ]=, and =( )=, the =<enter><enter>= will not
work. It will wait to evaluate the statements until you are outside of the nested brackets. This
means that if inside of a class, enum, function, or closure, you can hit =<enter>= as many times
as you want.

For example:

#+begin_example
0: fn fib(n) {
1:      if n < 2 {
2:              return n;
3:      }
4:
5:      return fib(n-1)+fib(n-2);
6: }
7: class Point [x, y] {
8:      @pub x = x;
9:
10:     @pub y = y;
11:
12:     @pub fn sumxy() {
13:             return this.x + this.y;
14:     }
15: }
16:
<unit> -> unit
<unit> -> unit
0: Point(fib(10), fib(15));
1:
<Class Point { y = 610, x = 55 }> -> class
0:
#+end_example

Another cool benefit of using the REPL is importing local files. By using the
REPL command =:i= <file1> <file2> ... <fileN>, it will essentially just insert the code in those
files in-place. After doing so, you can use and test functions, classes, enums etc. right from within
the REPL.

*Note*: You can also still use the =import= statement as well. See [[Imports][Imports]].

*Note*: The REPL uses some colors and if undesired can be disabled by using the =--repl-nocolor= flag.

*Note*: The REPL saves your history and stores it in =~/.earl_history= and will be cleared every time
it hits 1MB in file size.
#+end_quote

* Keywords

|---------|
| let     |
| fn      |
| if      |
| else    |
| while   |
| for     |
| foreach |
| import  |
| return  |
| in      |
| module  |
| class   |
| true    |
| false   |
| none    |
| match   |
| when    |
| break   |
| enum    |
| almost  |
| full    |
| to      |
| @ref    |
| @pub    |
| @world  |

* Variable Declarations

** Grammar

=let= <id> = /expr/;

** Examples

#+begin_example
let k = 1;
let x = func(k);
let y = [1,2,3];
let z = (0..10).rev().filter(|x| { return x % 2 == 0; });
#+end_example

* Mutation

#+begin_quote
Mutation describes changing a variables value in memory.
#+end_quote

** Grammar

/expr/ = /expr/;

** Examples

#+begin_example
k = 1;
k = 3+9;
k = (3+3)*2;
lst[3] = 9+23;
lst[3].nth(1) = 9+23;
#+end_example

** Shorthand

#+begin_quote
For convenience, there are some shorthand operations that can be performed.

#+begin_example
k += N # substitutes -> k = k + (N);
k -= N # substitutes -> k = k - (N);
k *= N # substitutes -> k = k * (N);
k /= N # substitutes -> k = k / (N);
k %= N # substitutes -> k = k % (N);
#+end_example
#+end_quote

* Conditionals

#+begin_quote
Conditionals are =if=, =if-else=, and =if-else-if= statements.
If the expression is true, that branch will occur.
#+end_quote

** Grammar

=if= /expr/ *{* [stmt] *}*

=else if= /expr/ *{* [stmt] *}*

=else= *{* [stmt] *}*

** Examples

#+begin_example
if k == 2 {
    # code
}
else if (k+1 == 9) {
    # code
}
else {
    # code
}
#+end_example

* Pattern Matching

#+begin_quote
Pattern matching allows you to match on some pattern. This is
the case for all primitives =int=, =str=, =list= etc.

A =match= consists of a two things.
1. The pattern \rightarrow this comes right after the =match= keyword
2. Branches \rightarrow these are all the different patterns can be

Each branch can either specify one pattern or multiple patterns with the =|= (or) operator.
The =when= keyword acts as a /guard/ for the branch. If the pattern matches, only then is the
/guard/ evaluated. If the /guard/ is true, only then will the branch activate.

And finally, the base case consists of the pattern =_=. If none of the other branches *above* this
one happens, this one is guaranteed to happen (unless there is a guard).
#+end_quote

Grammar TODO

** Examples

#+begin_example
let x = 4;
let msg = "foo";

match x {
    1 -> { print("x is 1"); }
    2 | 3 -> { print("x is two or three"); }
    [1,2,3] when type(x) == "list" -> { print(x is a list and is [1,2,3]") };
    4 when msg = "bar" -> { print("x is 4 with msg = bar"); }
    4 when msg = "foo" -> { print("x is 4 with msg = foo"); }
    _ when msg = "hello" -> { print("base case, 4 is something else and msg = hello"); }
    _ -> { print("base case, 4 is something else"); }
}
#+end_example

Output:

#+begin_example
x is 4 with msg = foo
#+end_example

#+begin_example
let x = some(4);

match x {
    none -> {
        print("x is none");
    }
    some(3) -> {
        print("x is some 3");
    }
    some(k) when k % 2 == 1 -> {
        print("x is something and is odd");
    }
    some(k) -> {
        # This branch will execute.
        # `k` is the unwrapped value of `x`.
        print("x is: ", k);
        print(x.unwrap() == k);
    }
    some(_) -> {
        print("x is something");
    }
    _ -> {
        print("x is something else");
    }
}
#+end_example

Output:

#+begin_example
x is: 4
true
#+end_example

* While Loops

#+begin_quote
=while= loops will continue to loop while the expression is =true=.
#+end_quote

** Grammar

=while= /expr/ *{* [stmt] *}*

** Examples

#+begin_example
let i = 0;
while i < 3 {
    print(i);
    i += 1;
} # prints 012
#+end_example

* For Loops

#+begin_quote
For loops will enumerate over a range of numbers, with the enumerator being assigned the current number.
If the enumerator is less than the initial destination value, it will be incremented. If it is less than the
initial destination value, it will decrement.
#+end_quote

** Grammar

=for= <id> =in= /expr/ =to= /expr/ *{* [stmt] *}*

** Examples

#+begin_example
for i in 0 to 5 {
    print(i);
} # prints 01234

for i in 5 to 0 {
    print(i);
} # prints 54321

let lst = [1,2,3];
for i in 0 to len(lst) {
    print(lst[i]);
} # prints 123

for i in len(lst)-1 to 0 {
    print(lst[i]);
} # prints 321
#+end_example

* Foreach Loops

#+begin_quote
Foreach loops take a list, string, or tuple and will iterate over the elements.
The most common way to use these loops is with a =range=. Also, the iterator
(usually the variable labeled as $i$), can be set as a reference to the expression.
This means that $i$ will be take the reference of each iterated value in the list and can modify it directly
(see /ref example/ below).
#+end_quote

** Grammar

=for= ?(=@= =ref=) <id> =in= /expr/ *{* [stmt] *}*

** Examples

#+begin_example
for i in 0..5 {
    print(i);
} # prints 12345

let iterable = [9,4,2];
for i in iterable {
    print(i);
} # prints 942

for i in (0..5).rev() {
    print(i);
} # prints 43210

for i in 0..len(iterable) {
    print(i);
} # prints 012

for @ref i in iterable { # REF EXAMPLE
    i = 9;
}
println(iterable); # prints [9, 9, 9]

for i in "foo" {
    print(i);
} # prints foo

for i in 'a'..'d' {
    print(i);
} # prints abc

let s = "bar";
for i in s {
    print(i);
} # prints bar
#+end_example

* Function Definitions

#+begin_quote
This is how to create a function. The =@world=, =@pub= and =@ref= are attributes. See [[Attributes]] for a description on them.
#+end_quote

** Grammar

#+begin_quote
*( =@= [ =pub= | =world= ])

=fn= <id> *(* [ * ( =@ref= ) <id> ] *)* *{* [stmt] *}*
#+end_quote

** Examples

#+begin_example
@world @pub
fn func1(@ref x, y, @ref z) {
    ...
}

fn func2() {
    ...
}
#+end_example

* Imports

#+begin_quote
EARL looks for the files relative to the directory
that it was invoked in. During runtime, if an =import=
statement is hit, it will immediately interpret that file.
If there is no processing in the =@world= scope, only the
function definitions and classes are gathered.

When importing, a depth can be specified. Use =full=
if you want all public elements from the file (enums, functions, variables, classes, etc.),
or =almost= if you only desire variables and enums. If none is provided, =full= will be used.
#+end_quote

** Grammar

#+begin_quote
=import= "filepath" ?(=full= | =almost=)
#+end_quote

** Examples

#+begin_example
# stdlib imports
import "std/list.earl" full
import "std/math.earl" # uses `full`
import "std/utils.earl" almost

# local imports
import "my-local-file.earl" almost
#+end_example

* Modules

#+begin_quote
/Modules/ allow other files to access resources to the
file that has the module declared in it. If a file does
not have it, the entire file is private. While modules
do allow other files to access resources, only resources
that have the =@pub= attribute.

To access some identifer from a different module, you use =::= syntax
(similar to C++ namespaces).

*It is expected to have the module declaration at the top of the file.
If you do not follow this rule, undefined behavior will occur.*
#+end_quote

** Grammar

#+begin_quote
=module= <id>
#+end_quote

** Examples

file: =my-math.earl=
#+begin_example
module MyMath

# Function is marked as @pub to make it
# accessible to other modules.
@pub fn sum(a, b) {
    return a+b;
}
#+end_example

file: =main.earl=
#+begin_example
module Main

import "my-math.earl" full

let s = MyMath::sum(1, 2);
#+end_example

* Attributes

#+begin_quote
Attributes embeds meta information into identifiers. You can have none, one, or multiple.

| Name     | Variables | Functions | Classes       | Enumerations  | Description                                                  |
|----------+-----------+-----------+---------------+---------------+--------------------------------------------------------------|
| =@pub=   | YES       | YES       | YES           | YES           | Makes the identifier available to other files                |
| =@world= | NO        | YES       | UNIMPLEMENTED | UNIMPLEMENTED | The identifier closes in the world scope                     |
| =@ref=   | YES       | NO*       | NO            | NO            | Declares the variable to be a reference (see the note below) |


*NOTE:* =@ref= can be used in a function parameter and that function will
take a reference to the value passed to it.
#+end_quote

** Grammar

#+begin_quote
=@= *(pub | world | ref)
#+end_quote

** Examples

#+begin_example
@world @pub
fn test_world() {
    # `i` will print since it is in the world scope.
    # The function is also marked as public so other
    # modules can have access to this function.
    print(i)
}

@pub fn take_ref(@ref ptr) {
    ptr = ptr + 1;
}

let i = 1;
test_world();

@ref let ptr = i;
ptr = ptr + 1;

assert(ptr == 2 && i == 2);

take_ref(i);

assert(i == 3);

#+end_example

* Enumerations

#+begin_quote
Enumerations (/enums/) act as it's own datatype, but they are just integers.
They compose of comma separated identifiers and each identifier can optionally
have an assignment to it. By default, if no assignments are made, it starts
at 0 and increments by 1 for each enum item. Once an assignment is found,
it will start incrementing from _that number_.

To access an enum element, use the dot `.` notation i.e, =MyEnum.Element1= and
can be accessed from other modules using the double colon `::` notation (as long as
it has the =@pub= attribute).

An /enum/ can consist of multiple datatypes, however, once a datatype other than
an integer is encountered, all values of the entries in the /enum/ _must_ be specified.
#+end_quote

** TODO Grammar

** Examples

#+begin_example
import "external-enum.earl" almost

@pub enum MyPubEnum {
    El1,     # contains 0
    El2 = 2, # contains 2
    El3,     # contains 3
    El4 = 9, # contains 9
    El5,     # contains 10
    El6,     # contains 11
}

let my_enum_el = MyPubEnum.El2;
println(my_enum_el, ' ', MyPubEnum.El5); # prints `2 10`
println(ExternalEnum::MyEnum.Item3); # prints the enum element from "external-enum.earl"
#+end_example

#+begin_example
let x = [1,2,3];

# All values are must be explicit if datatypes other
# than integers are used.
enum MixedEnum {
    El1 = 0,
    El2 = "hello",
    El3 = some(some('a')),
    El4 = x
}
#+end_example

* Classes

#+begin_quote
While classes are available, support for inheritance is not yet implemented.
1. All member variable assignments will happen. If the class has bracket notation =[ ... ]=,
   it will use these.
2. If there is a function called =constructor= in the class, that function will immediately happen.
3. For visibility:
   - All member variables that have the =@pub= attribute will be visible outside of the class scope, including other modules (if the class is marked as =@pub=).
   - All methods that have the =@pub= attribute will be visible outside of the class scope, including other modules (if the class is marked as =@pub=).
   - Everything that does not have =@pub= will only be visibile to the class scope.
4. The use of the =this= keyword is optional.
#+end_quote

** Grammar

#+begin_quote
=@= *(pub | world | ref)

=class= <id> ?(=[= <arg1>, <arg2>,..., <argN> =]=) ={=

    =@= *(pub | world | ref) <member1> = <id> | /expr/ =;=

    =@= *(pub | world | ref) <member2> = <id> | /expr/ =;=

    <methods>

=}=
#+end_quote

** Examples

#+begin_example
# This class takes no arguments for the
# constructors and is also not public,
# so other modules cannot use this class.

class NoPassesArgs [] {
    x = 1;
    y = 2;

    @pub fn print() {
        # The use of `this` keyword is optional.
        # Because this function is marked as @pub,
        # it is visible to the outside.
        print(this.x, y);
    }
}
#+end_example

#+begin_example
# This class is marked as @pub, so it is
# visible to other modules.
@pub class Point [x, y, name] {
    @pub x = x;
    @pub y = y;
    name = name;

    # Because this is public, you can access
    # it directly from outside the class.
    @pub desc = "A point class"

    # Function not marked as @pub so
    # it does is not visible outside
    # of this class.
    fn helper() {
        println("in helper");
    }

    @pub fn set_x(newx) {
        this.x = newx
    }

    @pub fn show() {
        print(this.x);
        print(this.y);
        print(this.name);
        print(this.desc);
    }
}
#+end_example

#+begin_example
@pub class Stack [init] {

    ### THIS HAPPENS FIRST ######
    # You could just assign `init` to `lst` here,
    # but for this example, this is done in the constructor.
    lst = [];
    sz = 0;
    ############################


    ### THIS HAPPENS SECOND #######
    # The constructor gets called
    # right after class instantiation.
    fn constructor() {
        for i in 0..len(init) {
            this.push(init[i]);
        }
    }
    ###############################

    @pub fn push(x) {
        this.lst.append(x);
        this.sz = this.sz+1;
    }

    @pub fn pop() {
        this.lst.pop(this.sz-1);
        this.sz = this.sz-1;
    }
}
#+end_example

* Datatypes

#+begin_quote
The following is a list of the currently implemented primitive types.
#+end_quote

** =int=

#+begin_quote
Your basic 32 bit integer datatype.

*Note*: They *do* over/under-flow
#+end_quote

** =float=

#+begin_quote
Your basic 64 bit floating pointer number.

*Note*: They *do* over/under-flow
#+end_quote

** =bool=

#+begin_quote
The boolean datatype. Can either be =true= or =false=.
#+end_quote

** =char=

#+begin_quote
A single character. They are surrounded by single quotes ='=.
#+end_quote

** =str=

#+begin_quote
A string is a list of =char='s. They are surrounded with double quotes ="=.
#+end_quote

** =list=

#+begin_quote
A list is a growable array. They can hold any datatype, and you
can even mix multiple datatypes in a single list. They can be initialized with
braces or a =range=.

#+begin_example
let lst0 = [];
let lst1 = [1,2,3];
println(lst0); # prints []
println(lst1); # prints [1, 2, 3]

let lst2 = 1..3;
let lst3 = (1..3).rev();
let lst4 = 'a'..'c';
println(lst2); # prints [1, 2];
println(lst3); # prints [2, 1];
println(lst4); # prints ['a', 'b'];
#+end_example
#+end_quote

** =tuple=

#+begin_quote
A =tuple= is the exact same thing as a =list= except they are /immutable/.
You cannot reassign, append, or modify a =tuple=. You can use bracket notation
=[]= to index values.

They can be created by using parenthesis and having elements be separated by commas _(including tuples of size 1)_:

#+begin_example
let tuple = (1, 'a', [1,2,3]);
tuple.foreach(|x| { println(x); });

let single_elem_tuple = (1,);
println(single_elem_tuple[0]);
#+end_example

*Note*: If an empty =tuple= is desired (for whatever reason), you can use the intrinsic casting
function =tuple()=.
#+end_quote

** =option=

#+begin_quote
Because all variables need to be initialized when using a `let` statement,
it may be annoying to be forced to give it some initial value. The =none= type
allows you to set a variable to it and can be reassigned later.

To assign a value to a none-type, you must wrap it in =some= i.e.,

=let x = none;=

=x = some(9);=

The underlying value (in the above example, =9=) can be extracted out
using the =unwrap()= member intrinsic.
#+end_quote

** =closure=

#+begin_quote
Closures are anonymous functions that close in the outer scope. They
can be used as functions or passed around as variables.

#+begin_example
fn take_sum_closure(f, a, b) {
    f(a, b);
}

let msg = "hello world";
let hello = |_| {
    print(msg);
};

let sum = |a, b| {
    print("in sum");
    return a+b;
};

hello();

print(take_sum_closure(sum, 1, 2));
#+end_example

Output:
#+begin_example
hello world
in sum
3
#+end_example

#+end_quote

** =file=

#+begin_quote
The =file= type is a file handler. It handles opening, closing, reading, and writing
to files.

*Note*: It is up to the user to =close()= the file handle.
#+end_quote

** =unit=

#+begin_quote
The =unit= type is used as a "throwaway". It essentially throws
away the value that gets assigned to it. The following are all
examples of correct usage of it:

=let _ = print("hello");=

=let _ = 1;=

=let cl = |_| { print("hello"); };=

=match x { _ -> { print("example"); } }=
#+end_quote

* Binary Operations

#+begin_quote
In the table below, the datatypes section describes which datatypes
are able to use the binary operations. This does not mean that if an
entry has (=int=, =list=), that you can add an integer to a list. Rather, it is
describing that the operator works for (=int= <op> =int=) or (=list= <op> =list=).
The exception is that you can add a =char= to a =str=.
#+end_quote

| Symbol | Datatypes                                                        | Description                      |
|--------+------------------------------------------------------------------+----------------------------------|
| +      | =int=, =float=, =list=, =str=                                    | Adds the elements together       |
| -      | =int=, =float=                                                   | Subtracts the elements           |
| *      | =int=, =float=                                                   | Multiplies the elements together |
| ///    | =int=, =float=                                                   | Divides the elements             |
| %      | =int=                                                            | Produces the modulo              |
| >      | =int=, =float=                                                   | Greater than                     |
| <      | =int=, =float=                                                   | Less than                        |
| >=     | =int=, =float=                                                   | Greater than or equal to         |
| <=     | =int=, =float=                                                   | Less than or equal to            |
| ==     | =bool=, =int=, =str=, =float=, =char=, =list=, =option=, =tuple= | Equal to                         |
| !=     | =bool=, =int=, =str=, =float=, =char=, =list=, =option=, =tuple= | Not equal to                     |
| &&     | =bool=                                                           | Logical AND                      |

=||=, =bool= \rightarrow Logical OR (this had to be separate to not misformat the table above)

* Intrinsics

#+begin_quote
Intrinsics are functions that are automatically built into the interpreter.
You do not need to import anything to use these functions.
#+end_quote

** =print=

#+begin_quote
#+begin_example
print(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements if it can.
#+end_quote

** =println=

#+begin_quote
#+begin_example
println(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements if it can. Adds a newline at the end.
#+end_quote

** TODO =fprint=

#+begin_quote
#+begin_example
fprint(fd: int|file, arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements to the file descriptor =fd=.
#+end_quote

** TODO =fprintln=

#+begin_quote
#+begin_example
fprintln(fd: int|file, arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will print all elements as well as a newline to the file descriptor =fd=.
#+end_quote

** =input=

#+begin_quote
#+begin_example
input(arg1: any, arg2: any, ..., argN: any) -> str
#+end_example

Will print all elements if it can. Gets input from the user
and returns it as a =str=.
#+end_quote

** =int=

#+begin_quote
#+begin_example
int(arg: int|float|str|bool) -> int
#+end_example

Casts =arg= to an =int=.
#+end_quote

** =float=

#+begin_quote
#+begin_example
float(arg: int|float|str) -> float
#+end_example

Casts =arg= to a =float=.
#+end_quote

** =str=

#+begin_quote
#+begin_example
str(arg: int|float|str|bool|option) -> str
#+end_example

Casts =arg= to a =str=.
#+end_quote

** =bool=

#+begin_quote
#+begin_example
bool(arg: int|float|str) -> bool
#+end_example

Casts =arg= to a =bool=.
#+end_quote

** =tuple=

#+begin_quote
#+begin_example
tuple(arg0: any, arg1: any, ..., argN: any) -> tuple
#+end_example

Cast the values to a =tuple=. You can also supply 0 arguments to create an empty =tuple=.
#+end_quote

** =list=

#+begin_quote
#+begin_example
list(arg0: any, arg1: any, ..., argN: any) -> list
#+end_example

Cast the values to a =list=. You can also supply 0 arguments to create an empty =list=.
#+end_quote

** =assert=

#+begin_quote
#+begin_example
assert(arg1: bool, arg2: bool, ..., argN: bool) -> unit
#+end_example

Tests each argument. If any of the conditions fail,
the program immediately crashes.
#+end_quote

** =len=

#+begin_quote
#+begin_example
len(arg: list|str|tuple) -> int
#+end_example

Expects either a =list=, =string=, or =tuple=. Will give the length
as an integer.
#+end_quote

** =some=

#+begin_quote
#+begin_example
some(arg: any) -> option<any>
#+end_example

Wraps =arg= in an =option= type.
#+end_quote

** =type=

#+begin_quote
#+begin_example
type(arg: any) -> str
#+end_example

Returns the type of =arg= as a =str=.
#+end_quote

** =argv=

#+begin_quote
#+begin_example
argv() -> list
#+end_example

Returns a list of =str= of the supplied command line arguments
that were given by the =--= option.
#+end_quote

** =open=

#+begin_quote
#+begin_example
open(fp: str, mode: str) -> file
#+end_example

Opens the filepath =fp= with mode =mode=. Mode must either be
=r= for read, =w= for write, or =b= for binary. You can also
supply multiple modes by combining the letters into a single =str=
i.e., ="wrb"=.
#+end_quote

** =unimplemented=

#+begin_quote
#+begin_example
unimplemented(arg1, arg2, ..., argN)
#+end_example

Prints "UNIMPLEMENTED" arg1..arg$N$ to =stderr= and exits with non-zero exit code.
#+end_quote

* Member Intrinsics

#+begin_quote
Member intrinsics are the same as intrinsics, except they are
member functions (or methods) that types have built into them.
You access these with the dot `.` notation i.e.,

=let lst = [1,2,3];=

=lst.rev();=
#+end_quote

** =list= Implements

#+begin_quote
#+begin_example
append(arg1: any, arg2: any, ..., argN: any) -> unit
#+end_example

Will append arg1..arg$N$ to the list.
#+end_quote

#+begin_quote
#+begin_example
pop(idx: int) -> unit
#+end_example

Will remove the element at index =idx=.
#+end_quote

#+begin_quote
#+begin_example
rev() -> list
#+end_example

Returns a new list that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> list
#+end_example

Takes the closure =cl= and creates a new =list= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

** =str= Implements

#+begin_quote
#+begin_example
append(arg1: char|str, arg2: char|str, ..., argN: char|str) -> unit
#+end_example

Will append arg1..arg$N$ to the =str=.
#+end_quote

#+begin_quote
#+begin_example
pop(idx: int) -> unit
#+end_example

Will remove the element at index =idx=.
#+end_quote

#+begin_quote
#+begin_example
rev() -> str
#+end_example

Returns a new =str= that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> str
#+end_example

Takes the closure =cl= and creates a new =str= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

#+begin_quote
#+begin_example
split(delim: str) -> list
#+end_example

Split a string by the delimiter =delim=.
#+end_quote

** =tuple= Implements

#+begin_quote
#+begin_example
rev() -> tuple
#+end_example

Returns a new tuple that is the reverse of the original.
#+end_quote

#+begin_quote
#+begin_example
filter(cl: closure) -> tuple
#+end_example

Takes the closure =cl= and creates a new =tuple= of all the
elements where =cl= returns =true=.
#+end_quote

#+begin_quote
#+begin_example
foreach(cl: closure) -> unit
#+end_example

Calls the closure =cl= on each element.
#+end_quote

** =char= Implements

#+begin_quote
#+begin_example
ascii() -> int
#+end_example

Returns the ascii code of the character.
#+end_quote

** =option= Implements

#+begin_quote
#+begin_example
is_none() -> bool
#+end_example

Returns =true= if the value is =none=, =false= otherwise.
#+end_quote

#+begin_quote
#+begin_example
is_some() -> bool
#+end_example

Returns =true= if the value is =some=, =false= otherwise.
#+end_quote

#+begin_quote
#+begin_example
unwrap() -> any
#+end_example

Returns the inner value of the =option= datatype. If the =option= is
=none=, a panic will occur.
#+end_quote

** =file= Implements

#+begin_quote
#+begin_example
close() -> unit
#+end_example

Closes an opened file.
#+end_quote

#+begin_quote
#+begin_example
read() -> str
#+end_example

Get the contents of a file as a =str=.
#+end_quote

#+begin_quote
#+begin_example
dump() -> unit
#+end_example

Print the contents of a file.
#+end_quote

#+begin_quote
#+begin_example
write(msg: str|char|int) -> unit
#+end_example

Writes =msg= to the opened file.
#+end_quote

#+begin_quote
#+begin_example
writelines(msg: list) -> unit
#+end_example

Writes all elements in the list =msg= to the opened file.
At the end of each value, a newline is added.
#+end_quote

* StdLib

#+begin_quote
Upon installing EARL, the standard library is installed into
=/usr/local/include/EARL/std=. The first place that EARL looks
when evaluating an =import= statement is =/usr/local/include/EARL/=.
This means that all you need to do to import these files is do:
=import "std/<file>.earl"= <depth>.
#+end_quote

** Stack

*** *Import*: ="std/stack.earl"=

*** *Module*: =Stack=

*** *Class List*:

#+begin_quote
#+begin_example
T [init: list] -> Stack::T
#+end_example

Creates a =Stack= container with the initializer list =init=.
#+end_quote

*** Implements

#+begin_quote
#+begin_example
push(elem: any) -> unit
#+end_example

Inserts =elem= onto the top of the stack.
#+end_quote

#+begin_quote
#+begin_example
pop() -> unit
#+end_example

Removes the most recently inserted element.
#+end_quote

#+begin_quote
#+begin_example
top() -> any
#+end_example

Get the most recently added item.
#+end_quote

#+begin_quote
#+begin_example
empty() -> bool
#+end_example

Check if the stack is empty
#+end_quote

*** *Function List*: /None/

*** *Enum List*: /None/

*** *Variable List* /None/

*** *Examples*

#+begin_example
let s = Stack.T([]);

for i in 0..10 {
    s.push(i);
}

while s.empty() != true {
    print(s.top());
    s.pop();
}
#+end_example

#+begin_example
9
8
7
6
5
4
3
2
1
#+end_example

** Set

*** *Import*: ="std/set.earl"=

*** *Module*: =Set=

*** *Class List*:

#+begin_quote
#+begin_example
T [init: list, compar: closure(x1: any, x2: type(x1)) -> int] -> Set::T
#+end_example

where =compar= is some ordering function $F(x_1, x_2) \rightarrow k \in \{2,1,0\}$

and $F$ is defined by

\[
F(x_1, x_2) = \begin{cases}
      2 & \text{if } R(x_1) > R(x_2) \\
      1 & \text{if } R(x_2) > R(x_1) \\
      0 & \text{if } R(x_1) = R(x_2)
   \end{cases}
\]

and $R(x)$ is some ranking function that produces a rank of $x$.

Creates a =Set= container with the initializer list =init= and the
comparison function =compar=. This container stores the values
in a binary search tree, so it needs to know how to compare the values
and decide which is bigger and which isn't.

Time complexity: $O(n \log n)$ where $n = |$ =init= $|$.

#+end_quote

*** Implements

#+begin_quote
#+begin_example
insert(elem: any) -> unit
#+end_example

Inserts =elem= into the =set=.

Time complexity: $O(\log n)$ where $n = |$ =T= $|$.
#+end_quote

#+begin_quote
#+begin_example
contains(elem: any) -> bool
#+end_example

Check if =elem= is in the set.

Time complexity: $O(\log n)$ where $n = |$ =T= $|$.
#+end_quote

#+begin_quote
#+begin_example
extract() -> list
#+end_example

Extracts the elements of the set as a =list=.

Time complexity: $O(\log n)$ where $n = |$ =T= $|$.
#+end_quote

#+begin_quote
#+begin_example
dump() -> unit
#+end_example

Prints the contents of the =set=.

Time complexity: $O(\log n)$ where $n = |$ =T= $|$.
#+end_quote

*** *Enum List*: /None/

*** *Function List*: /None/

*** *Variable List*

#+begin_quote
#+begin_example
DEFAULT_INT_SET_COMPAR: closure(any, any) -> int
#+end_example

The default integer comparison function.
#+end_quote

** List

*** *Import*: ="std/list.earl"=

*** *Module*: =List=

*** *Class List*: /None/

*** *Enum List*: /None/

*** *Function List*:

#+begin_quote
#+begin_example
preset(elem: any, cap: int) -> list
#+end_example

Create a list filled with =elem= of length =cap=.

Time complexity: $O(n)$ where $n =$ =cap=.
#+end_quote

#+begin_quote
#+begin_example
from_range(start: int, stop: int, stride: int) -> list[int]
#+end_example

Create a list filled with the numbers from =start= to =stop= (inclusive)
and increment the number by =stride=.

Time complexity: $O(n)$ where $n =$ (=stop= - =start=) / =stride=.
#+end_quote

#+begin_quote
#+begin_example
fill(@ref lst: list, k: any) -> unit
#+end_example

Fill the list =lst= with element =k=.

Time complexity: $O(n)$ where $n = |$ =lst= $|$.
#+end_quote

#+begin_quote
#+begin_example
sum(@ref lst: list[int]) -> int
#+end_example

Sum up all elements of the list =lst=.

Time complexity: $O(n)$ where $n = |$ =lst= $|$.
#+end_quote

#+begin_quote
#+begin_example
find(@ref lst: list, @ref elem: any) -> int
#+end_example

Return the index that =elem= appears in =lst=. Returns =-1=
if it does not exist.

Time complexity: $O(n)$ where $n = |$ =lst= $|$.
#+end_quote

#+begin_quote
#+begin_example
count(@ref lst: list, @ref elem: any) -> int
#+end_example

Count the number of times that =elem= appears in =lst=.

Time complexity: $O(n)$ where $n = |$ =lst= $|$.
#+end_quote

#+begin_quote
#+begin_example
quicksort(@ref lst: list, compar: closure) -> unit
#+end_example

where =compar= is some ordering function $F(x_1, x_2) \in \{true, false\}$

and $F$ is defined by

\[
F(x_1, x_2) = \begin{cases}
      true & \text{if } R(x_1) \ge R(x_2) \\
      false & \text{if } R(x_1) < R(x_2)
   \end{cases}
\]

and $R(x)$ is some ranking function that produces a rank of $x$.

Performs the quicksort sorting algorithm on =lst= and
sorts by the comparison closure =compar=.
#+end_quote

*** *Variable List* /None/

** IO

*** *Import*: ="std/io.earl"=

*** *Module*: =IO=

*** *Class List*: /None/

*** *Enum List*:

#+begin_quote
#+begin_example
Fd {
    In -> int,
    Out -> int,
    Err -> int
}
#+end_example

The integer codes for =stdin=, =stdout=, and =stderr=.
#+end_quote

*** *Function List*:

#+begin_quote
#+begin_example
file_to_str(fp: str) -> str
#+end_example

Opens the file at the filepath =fp= in read (=r=) mode. Returns
the contents of the file as a =str= and closes the file.
#+end_quote

*** *Variable List* /None/

** Math

*** *Import*: ="std/math.earl"=

*** *Module*: =Math=

*** *Class List*: /None/

*** *Enum List*: /None/

*** *Function List*:

#+begin_quote
#+begin_example
max(x: int, y: int) -> int
#+end_example

Returns the max between =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
min(x: int, y: int) -> int
#+end_example

Returns the min between =x= and =y=.
#+end_quote

#+begin_quote
#+begin_example
abs(x: int) -> int
#+end_example

Returns the absolute value of =x=.
#+end_quote

*** *Variable List* /None/

** Utils

*** *Import*: ="std/utils.earl"=

*** *Module*: =Utils=

*** *Class List*: /None/

*** *Enum List*: /None/

*** *Function List*:

#+begin_quote
#+begin_example
is_even(n: int) -> bool
#+end_example

Returns =true= if =n= is even, =false= if odd.
#+end_quote

#+begin_quote
#+begin_example
swap(@ref x1, @ref x2) -> unit
#+end_example

Swaps the values of =x1= and =x2=.
#+end_quote

*** *Variable List* /None/

* Code Style

I don't care how you style your code, do whatever you want. However, when contributing to the
=stdlib=, please follow the below guidelines.

** Identifier Names

#+begin_quote
Function and variable identifiers should have =snake_case= naming.
#+end_quote

#+begin_example
let my_var = 1;
let my_var2 = "foo";

fn my_local_function(my_param) {
    println(my_param);
}
#+end_example

#+begin_quote
Modules and classes should have =PascalCase= naming.
#+end_quote

#+begin_example
module MyModule

class MyClass [] {
    ...
}
#+end_example

** Attributes

#+begin_quote
If a function/variable/class has _one_ attribute, then it should be put
_before and on the same line_ as the identifier.

If it has _more than one_ attribute, it should be put on the line
_directly above_ the declaration.
#+end_quote

#+begin_example
@pub let my_var = 1;

@world fn my_fun(@ref x) {
    ...
}

@pub @ref
let ptr = @ref my_var;

@pub @world
fn my_fun2() {
    ...
}
#+end_example


